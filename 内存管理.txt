Python 内存管理机制


一、引用计数
	Python内部使用引用计数，记录对象有多少个引用，当对象被创建时就创建了一个引用计数，
	当对象不再需要时，这个对象的引用计数为0时，被垃圾回收
	a、对象引用计数增加
		1、对象被创建：x = 1
		2、对象被别的对象创建时引用：y = x
		3、对象被作为参数传递给函数: foo(x)
		4、对象作为容器对象的一个元素：a = [x, 2, 3]
		Tips：容器对象的引用可能构成很复杂的拓扑结构，可以用objgraph包来绘制其引用关系，比如：
			x = [1, 2, 3]
			y = [x, dict(key1=x)]
			z = [y, (x, y)]

			import objgraph
			objgraph.show_refs([z], filename='ref_topo.png')
			
	b、对象引用计数减少
		1.一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1。
		2、对象的别名被显式的销毁：del x ；或者del y
		3、对象的一个别名被赋值给其他对象：x=789
		4、对象从一个窗口对象中移除：myList.remove(x)
		5、窗口对象本身被销毁：del myList，或者窗口对象本身离开了作用域。


二、垃圾回收
	当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。
	垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。
	如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。
	当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。
	当两者的差值高于某个阈值时，垃圾回收才会启动。
	
	Tips：可以通过gc模块的get_threshold()方法，查看该阈值:
		import gc
		print(gc.get_threshold())
	返回为三元元祖,如：(700, 10, 10)后面的两个10是与分代回收相关的阈值，第一个10表示0代对象清理10次后对1代对象清理一次，
	第二个10表示1代对象清理10次后对2代对象清理一次。700即是垃圾回收启动的阈值。可以通过gc中的set_threshold()方法重新设置。
	*也可以手动启动垃圾回收，即使用gc.collect()。
	
	
三、分代回收
	Python同时采用了分代(generation)回收的策略
	Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。
	垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，
	那么会启动对0，1，2，即对所有对象进行扫描。
	这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，会配合1次1代的垃圾回收；而每10次1代的垃圾回收，
	才会有1次的2代垃圾回收。
	同样可以用set_threshold()来调整，比如对2代对象进行更频繁的扫描。
	
		
四、内存池机制
	Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。

	Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc。另外Python对象，如整数，浮点数和List，
	都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。