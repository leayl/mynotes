---
typora-root-url: ./
typora-copy-images-to: redis笔记
---

# redis面试突击

## 一、为什么使用缓存

在查询数据库之前添加一层redis缓存

1、高性能（动态页面静态化，将前几页数据放在缓存中）

2、高可用（高并发场景下使用，保护数据库）

## 二、缓存穿透、击穿、雪崩

1、缓存穿透：缓存和数据库中都查询不到，如果多次实行这样的查询，会对数据库造成危害

​	解决方案：

​		a、对参数合法性进行校验

​		b、将数据库中没有查询到的数据也写到缓存中（需要防止redis被无效数据占用，数据过期时间设置短）

​		c、在redis之前引入布隆过滤器（BloomFilter），在访问redis前判断数据是否存在。

​			注意：如果布隆过滤器判断元素不在集合中，就肯定不在，如果判断在的话，可能会存在误判，并且，布隆过滤器只能加数据，不能减数据

2、缓存击穿：缓存中没有，但是数据库中有的情况，一般出现在数据初始化和**热点key过期**的情况下，问题在于，重新写入缓存需要一定时间，如果是在高并发场景下，过多的请求就会瞬间写到DB上，造成数据库压力

​	解决方案：

​		a、设置这个热点缓存永不过期，这时要注意在value当中包含一个逻辑上的过期时间，然后另起一个线程，定期重建这些缓存。

​		b、在加载DB的时候，要防止并发，在DB向缓存写入的时候，加一个并发锁

3、缓存雪崩：缓存**大面积过期**，导致请求全部被转发到DB

​	解决方案：

​		a、把缓存失效时间分散开，例如，在原有的统一失效时间基础上，加一个随机值

​		b、对热点数据设置永不过期

## 三、如何保证redis与数据库内容一致

当我们对数据修改的时候，到底是先删缓存还是先写数据库

1、如果先删缓存，再写数据库：在高并发场景下，第一个线程删除了缓存，还没有来得及写数据库，第二个线程在缓存中为空的情况下会读取数据库中的数据（旧值，脏数据），读完之后又重新写入缓存（此时第一个线程已经将新的值写入到缓存中)，这样，缓存中的值就会被覆盖为修改前的脏数据

​	总结：在这种方式下，通常要求写操作频繁

​	解决方案：

​		a、先操作缓存，但是不删除缓存，将缓存修改为特殊值，客户端读缓存发现是默认值，就休眠一下，再去查一次redis。（特殊值对业务有侵入，休眠时间可能会多次重复，对性能有影响）

​		b、延时双删，先删除缓存，然后再写数据库，休眠一下，再次删除缓存（如果数据写操作频繁，同样还是会有脏数据的问题）

2、先写数据库，再删缓存：如果数据库写完了之后，缓存删除失败，数据就会不一致。

总结：始终只能保证一定时间内的最终一致性

​	解决方案：

​		a、给缓存设置一个过期时间，问题：过期时间内，缓存数据不会更新

​		b、引入MQ，保证原子操作，问题：MQ重试时间内，缓存数据也不会更新

解决方案：将热点数据缓存设置为永不过期，但是在value当中写入一个逻辑上的过期时间，另起一个后台线程，扫描这些key，对于已逻辑上过期的缓存，进行删除。

## 四、如何设计一个分布式锁，如何对锁性能进行优化

分布式锁的本质：在所有进程都能访问到的一个地方，设置一个锁资源，让这些进程都来竞争锁资源。数据库、zookeeper、redis......通常对于分布式锁，会要求响应快，性能高，与业务无关。

redis实现分布式锁：

​	SETNX  key value：当key不存在时，就将key设置为value，并返回1；如果key存在，就返回0。

​	EXPIRE key locktime：设置key的有效时长。

​	DEL key：删除。

​	GETSET key value：先GET，再SET ，先返回对应的值，如果没有就返回空，然后再将key设置为value。

1、最简单的分布式锁：SETNX 加锁， DEL解锁。问题：如果获取到锁的进程执行失败，就永远不会主动解锁，那这个锁就被锁死了。

2、给锁设置过期时长：问题：SETNX和EXPIRE并不是原子性的，所以获取到锁的进程可能还没有执行EXPIRE指令就挂了，这时锁还是会被锁死

3、将锁的内容设置为过期时间（客户端时间+过期时长），SETNX获取锁失败时，那这个时间跟当前时间比对，如果是过期的锁，就先删除锁，再重新上锁。问题：在高并发场景下，会产生多个进程同时拿到锁的情况

4、SETNX失败后，获取锁上的时间戳，然后用getset，将自己的过期时间更新上去，并获取旧值。如果这个旧值跟之前获取的时间戳是不一致的，就表示这个锁已经被其他进程占用了，自己就要放弃竞争。

5、上面就形成了一个比较搞笑的分布式锁。分析一下，上面各种优化的根本问题在于SETNX和EXPIRE两个指令无法保证原子性，redis2.6提供了直接执行lua脚本的方式，通过lua脚本来保证原子性。redission

## 五、redis如何配置key的过期时间，实现原理

redis设置key的过期时间：1、EXPIRE 2、SETEX

实现原理：

​	1、定期删除：每隔一段时间，执行一次删除过期key的操作。

​	2、懒汉式删除：当使用get、getset等指令去获取数据时、判断key是否过期，过期后，就把key删除，再执行后面的在操作。

​	redis是将两种方式结合来使用。

​	懒汉式删除

​	定期删除：要注意平衡执行频率和执行时长。

​	定期删除时会便利每个database（默认16个），检查当前指定个数的key（默认20个）。随机抽查这些key，如果有过期的，就删除。

​	程序中有一个全局变量记录到扫描到了哪个数据库。

## 六、海量数据下如何快速检索

1、使用布隆过滤器，快速过滤掉不存在电弧记录。

  	使用redis的bitmap结构来实现布隆过滤器

2、在redis中建立数据缓存，将我们对redis使用场景的理解尽量表达出来。

​		以普通字符串的形式来存储（userid->user.json）。以一个hash来存储一条记录（userid key->username filed->,userage->）。以一个整的hash来存储所有数据，userinfo->filed就用userid，value就用user.json。一个hash最多能支持2^32-1（40多亿）个键值对。

​		缓存击穿：对不存在的数据也简历key。这些key都是经过布隆过滤器过滤的，所以一般不会太多

​		缓存过期：将热点数据设置成永不过期，定期重建缓存。使用分布式锁重建缓存。

3、查询优化

​		redis是按槽位分配数据

​		可以自己实现槽位计算，找到记录应该分配在哪台机器上，然后直接去机器上找

## 七、数据持久化：RDB和AOF机制

![image-20210722235804380](/redis笔记/image-20210722235804380.png)

![image-20210723000140857](/redis笔记/image-20210723000140857.png)

## 八、redis的过期键的删除策略

![image-20210723000423332](/redis笔记/image-20210723000423332.png)

## 九、redis线程模型，单线程为什么快

![image-20210723000437336](/redis笔记/image-20210723000437336.png)



## 十、简述redis事务实现

![image-20210723000524205](/redis笔记/image-20210723000524205.png)

![image-20210723001002539](/redis笔记/image-20210723001002539.png)

![image-20210723001011339](/redis笔记/image-20210723001011339.png)

## 十一、redis集群方案

![image-20210723000517219](/redis笔记/image-20210723000517219.png)

![image-20210723000733043](/redis笔记/image-20210723000733043.png)

![image-20210723000704432](/redis笔记/image-20210723000704432.png)

![image-20210723000448334](/redis笔记/image-20210723000448334.png)

## 十二、redis主从复制的核心原理

![image-20210723000543406](/redis笔记/image-20210723000543406.png)

![image-20210723000557899](/redis笔记/image-20210723000557899.png)

![image-20210723000547765](/redis笔记/image-20210723000547765.png)